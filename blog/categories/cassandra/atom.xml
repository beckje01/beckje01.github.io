<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cassandra | Jeff Beck]]></title>
  <link href="http://beckje01.com/blog/categories/cassandra/atom.xml" rel="self"/>
  <link href="http://beckje01.com/"/>
  <updated>2015-07-12T21:30:01-05:00</updated>
  <id>http://beckje01.com/</id>
  <author>
    <name><![CDATA[Jeff Beck]]></name>
    <email><![CDATA[beckje01@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cassandra Stale Snapshots]]></title>
    <link href="http://beckje01.com/blog/2015/03/12/cassandra-stale-snapshots/"/>
    <updated>2015-03-12T09:47:19-05:00</updated>
    <id>http://beckje01.com/blog/2015/03/12/cassandra-stale-snapshots</id>
    <content type="html"><![CDATA[<p>While working with Cassandra we found that sometimes snapshots get left around after repairs fail or have issues. These can cause 100&rsquo;s of Gigs of space to just be wasted. This can add up quickly and cause issues. On a node with low disk space we can check for stale snapshots the following way.</p>

<p><code>sh
$ cd /cassandaData/cassandra/data/keyspace/
$ du -h
</code></p>

<p>If you see large or multiple directories under columnFamily/snapshots/ that may indicate there are stale snapshots that can be cleaned up.
We will want to check when these snapshots where created so inside the snapshots directory of the column family run</p>

<p><code>sh
$ ls -lah
total 3.3M
drwxr-xr-x 7 cassandra cassandra 4.0K Mar 11 16:14 .
drwxr-xr-x 3 cassandra cassandra 704K Mar 11 16:31 ..
drwxr-xr-x 2 cassandra cassandra 508K Mar 01 14:24 4f37dcd0-c7fa-11e4-b5ae-5f969a9b23c8
drwxr-xr-x 2 cassandra cassandra 504K Mar 11 16:14 ad70a8e0-c809-11e4-9b55-39152d07d3bf
drwxr-xr-x 2 cassandra cassandra 532K Mar 11 16:03 b5cfd3a0-c807-11e4-bcd5-db76d671c3d5
drwxr-xr-x 2 cassandra cassandra 504K Mar 10 22:50 cfe34050-c777-11e4-b5ae-5f969a9b23c8
drwxr-xr-x 2 cassandra cassandra 536K Mar 11 16:09 edc03dd0-c808-11e4-be46-35521ca10087
</code></p>

<p>Each of those are snapshots but you will notice 4f37dcd0-c7fa-11e4-b5ae-5f969a9b23c8 is stale, we can now clean that up with the <a href="http://www.datastax.com/documentation/cassandra/2.1/cassandra/tools/toolsClearSnapShot.html">nodetool clearsnapshot</a> command.
<code>
nodetool clearsnapshot keyspace -t 4f37dcd0-c7fa-11e4-b5ae-5f969a9b23c8
</code></p>

<p>That will take care of removing the stale snapshot you should see disk space recovered immediately.</p>

<p>You can also look in the logs for failed repairs we see something like the following:</p>

<p><code>
2015-02-20 23:37:52,220 RepairSession.java (line 288) [repair #72e69720-b959-11e4-9b55-39152d07d3bf] session completed with the following error
system.log.10-java.io.IOException: Failed during snapshot creation.
system.log.10- at org.apache.cassandra.repair.RepairSession.failedSnapshot(RepairSession.java:323)
system.log.10- at org.apache.cassandra.repair.RepairJob$2.onFailure(RepairJob.java:126)
system.log.10- at com.google.common.util.concurrent.Futures$4.run(Futures.java:1160)
system.log.10- at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
system.log.10- at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
system.log.10- at java.lang.Thread.run(Thread.java:745)
</code></p>

<p>In that case the bad snapshot would be <em>72e69720-b959-11e4-9b55-39152d07d3bf</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cassandra Upsert Everything]]></title>
    <link href="http://beckje01.com/blog/2014/08/13/cassandra-upsert-everything/"/>
    <updated>2014-08-13T18:16:00-05:00</updated>
    <id>http://beckje01.com/blog/2014/08/13/cassandra-upsert-everything</id>
    <content type="html"><![CDATA[<p>Cassandra inserts and updates should always be modeled as upserts when possible. Using the query builder in the Java native driver there isn&rsquo;t a direct upsert called out, but we can do updates instead of inserts for all cases. The update acts as an upsert and it reduces the number of queries you will need to build.</p>

<p>``` java
Statement upsert = QueryBuilder.update(&ldquo;table&rdquo;)</p>

<pre><code>    .with(QueryBuilder.append("visits", new Date())) //Add to a CQL3 List
    .where(QueryBuilder.eq("id", "MyID"));
</code></pre>

<p>session.execute(upsert);
```</p>

<p>Above you can see how we model our &ldquo;upsert&rdquo;. If a value isn&rsquo;t found for the given where clause it will insert it.</p>

<p>You must use all parts of a Primary Key for an updates where cluase given a CQL Table with a compound key:</p>

<p>```
create table tablex(</p>

<pre><code> pk1 varchar,
 pk2 varchar,
 colA varchar,
 PRIMARY KEY(pk1,pk2)
</code></pre>

<p>);
```
We can not do the following query:</p>

<p>``` java
Statement upsert = QueryBuilder.update(&ldquo;tablex&rdquo;)</p>

<pre><code>            .with(QueryBuilder.set("colA", "2"))
            .where(QueryBuilder.eq("pk1", "1"));
</code></pre>

<p>```</p>

<p>You will get an <code>InvalidQueryException</code>:</p>

<p>```
com.datastax.driver.core.exceptions.InvalidQueryException: Missing mandatory PRIMARY KEY part pk2</p>

<pre><code>com.datastax.driver.core.exceptions.InvalidQueryException.copy(InvalidQueryException.java:35)
com.datastax.driver.core.DefaultResultSetFuture.extractCauseFromExecutionException(DefaultResultSetFuture.java:256)
com.datastax.driver.core.DefaultResultSetFuture.getUninterruptibly(DefaultResultSetFuture.java:172)
</code></pre>

<p>```</p>

<p>But the following will upsert:</p>

<p>``` java
Statement upsert = QueryBuilder.update(&ldquo;tablex&rdquo;)</p>

<pre><code>    .with(QueryBuilder.set("colA", "2"))
    .where(QueryBuilder.eq("pk1", "1"))
    .and(QueryBuilder.eq("pk2", "2"));
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
