<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Grails | Jeff Beck]]></title>
  <link href="http://beckje01.com/blog/categories/grails/atom.xml" rel="self"/>
  <link href="http://beckje01.com/"/>
  <updated>2016-07-28T15:31:21-05:00</updated>
  <id>http://beckje01.com/</id>
  <author>
    <name><![CDATA[Jeff Beck]]></name>
    <email><![CDATA[beckje01@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grails 3.1.9 Functional Test Port]]></title>
    <link href="http://beckje01.com/blog/2016/07/28/grails-3-dot-1-9-functional-tests/"/>
    <updated>2016-07-28T14:31:24-05:00</updated>
    <id>http://beckje01.com/blog/2016/07/28/grails-3-dot-1-9-functional-tests</id>
    <content type="html"><![CDATA[<p>With Grails 3.1.9 and above we now get a default port for Functional tests that is randomly assigned. This is a great feature that was added in with this <a href="https://github.com/grails/grails-core/commit/0532f0cef10990c651c01300007458cba9efff86">commit</a>.</p>

<p>While this is a nice addition our tests which were not using Geb were left broken this is due to the fact we now need to know what port was selected for a given run of the tests. So our old test:</p>

<p>```groovy
@Integration
class UserEndpointSpec extends Specification {<br/>
  def &ldquo;POST new user&rdquo;() {</p>

<pre><code>given:
ResponseEntity&lt;Map&gt; resp
RestTemplate restTemplate = new RestTemplate()
def requestBody = [
    email: 'phil@aol.com',
    fullName: 'Phil',
    password: 'password',
    username: 'phil'
]

when:
resp = restTemplate.postForEntity("http://localhost:8080/users", requestBody, Map)

then:
resp.statusCode == HttpStatus.NO_CONTENT
</code></pre>

<p>  }
}
```</p>

<p>Was broken since the app no longer started on 8080, but we can fix that with a new property that the <code>@Integration</code> annotation adds which is <code>serverPort</code> so the test becomes:</p>

<p>```groovy
@Integration
class UserEndpointSpec extends Specification {<br/>
  def &ldquo;POST new user&rdquo;() {</p>

<pre><code>given:
ResponseEntity&lt;Map&gt; resp
RestTemplate restTemplate = new RestTemplate()
def requestBody = [
    email: 'phil@aol.com',
    fullName: 'Phil',
    password: 'password',
    username: 'phil'
]

when:
resp = restTemplate.postForEntity("http://localhost:${serverPort}/users", requestBody, Map)

then:
resp.statusCode == HttpStatus.NO_CONTENT
</code></pre>

<p>  }
}
```</p>

<p>If you are wondering how <code>serverPort</code> is actually set you can see it happening inside <a href="https://github.com/grails/grails-core/blob/bf2b027b59890446844756ca3d3124d3d033ea8e/grails-plugin-testing/src/main/groovy/org/grails/compiler/injection/test/IntegrationTestMixinTransformation.groovy#L138">IntegrationTestMixinTransformation</a>. It will add a property to the test class with the port.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails 3 Metrics and Path Variables]]></title>
    <link href="http://beckje01.com/blog/2016/06/19/grails-3-metrics-and-pathtokens/"/>
    <updated>2016-06-19T16:10:00-05:00</updated>
    <id>http://beckje01.com/blog/2016/06/19/grails-3-metrics-and-pathtokens</id>
    <content type="html"><![CDATA[<p>Grails 3 is built on top of SpringBoot on of the key components of SpringBoot is <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator">Actuator</a>. Actuator sets up Metrics and healthchecks all the things modern services are expected to just have. Grails 3 ships with the <code>/metrics</code> endpoint turned on meaning every request gets tracked by default the endpoint will be available to all logged in users assuming you are using some security.</p>

<p>Most of the time this wouldn&rsquo;t be an issue and would be very nice to have those metrics the problem comes to the fact that currently all requests with Path Variables are treated as different endpoints. So requests to <code>/items/$id</code> of <code>/items/123</code> and <code>/items/333</code> will end up listed as two different metrics with the value of the path variable for everyone to see. This exposes more data than intended and doesn&rsquo;t provide really useful metrics. Its due to an issue in Actuator <a href="https://github.com/spring-projects/spring-boot/issues/5875">GH Issue 5875</a>. So until this is fixed I recommend turning off metrics collection all together for Grails 3.</p>

<p>You can do that with the following config in your <code>application.yml</code></p>

<p>```yaml
endpoints:
  metrics:</p>

<pre><code>enabled: false
</code></pre>

<p>```</p>

<p>I just keep the metrics endpoint off since the health-checks are useful and something we depend on others may want to just shut of Actuator fully which can be done with:</p>

<p><code>yaml
endpoints:
   enabled: false
</code></p>

<p>Thanks to <a href="https://twitter.com/RyanVanderwerf">Ryan Vanderwerf</a> for help on this issue.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails 3 and JaCoCo]]></title>
    <link href="http://beckje01.com/blog/2015/07/12/grails-3-and-jacoco/"/>
    <updated>2015-07-12T21:29:00-05:00</updated>
    <id>http://beckje01.com/blog/2015/07/12/grails-3-and-jacoco</id>
    <content type="html"><![CDATA[<p>Now that we have Gradle as our build system we have a whole range of plugins we can use directly in Gradle. For code coverage I am using the JaCoCo plugin. To use it with Grails we just apply the plugin to the build. By default you will get a HTML report, in the <code>build/report/jacoco</code> directory.</p>

<p><code>groovy
apply plugin: "jacoco"
</code></p>

<p>But Grails 3 has it&rsquo;s test phases split up, out of the box you will have <code>test</code> and <code>integrationTest</code>. Starting with the JaCoCo gradle plugin, you will get coverage for just your <code>test</code> phase.</p>

<p>We can easily fix this by letting JaCoCo know about the phases we want reported on so we just adjust the config for the jacocoTestReport task.</p>

<p>```groovy
jacocoTestReport {</p>

<pre><code>executionData integrationTest, test
//...
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails 3 and Spring Java Config]]></title>
    <link href="http://beckje01.com/blog/2015/04/24/grails-3-and-spring-java-config/"/>
    <updated>2015-04-24T21:52:53-05:00</updated>
    <id>http://beckje01.com/blog/2015/04/24/grails-3-and-spring-java-config</id>
    <content type="html"><![CDATA[<p>The Spring Java config is a great way to work with Spring configuration. It feels similar to Google Guice, which I personally enjoy. Mr. Haki did a great write up on using it with <a href="http://mrhaki.blogspot.com/2014/08/grails-goodness-use-spring-java.html">Grails 2.4</a>.</p>

<p>While working with Grails 3 there are a few areas that don&rsquo;t have plugins yet but do have Spring modules we can leverage. So I started out with the same path given for Grails 2.X.</p>

<p>```yaml application.yml
grails:</p>

<pre><code>profile: web
codegen:
    defaultPackage: example
spring:
    bean:
        packages:
            - example.config
</code></pre>

<p>```</p>

<p>I found that while the beans were all wired correctly and <code>@Autowired</code> all worked correctly, but any mappings with <code>@RequestMapping</code> where always returning a 404. Everything looked wired correctly but Grails wasn&rsquo;t letting any requests through.</p>

<p>So I switched over to using <code>@ComponentScan</code> then the requests were properly mapped and everything started working.</p>

<p>Using ComponentScan with Grails 3 is very easy:</p>

<p><code>groovy Application.groovy
@ComponentScan("example.config")
class Application extends GrailsAutoConfiguration {
  //...
}
</code></p>

<p>This will scan the package of <code>example.config</code> for any Spring components so your Spring Java configs can all live in this package and easily get picked up.</p>

<p>This post is the blog form of this <a href="http://stackoverflow.com/questions/29736850/grails-3-and-spring-requestmapping">SO Question</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringSecurity Impersonate Users Custom Roles]]></title>
    <link href="http://beckje01.com/blog/2015/04/18/springsecurity-impersonate-users-custom-roles/"/>
    <updated>2015-04-18T20:54:00-05:00</updated>
    <id>http://beckje01.com/blog/2015/04/18/springsecurity-impersonate-users-custom-roles</id>
    <content type="html"><![CDATA[<p>The Grails SpringSecurity plugin has the ability to allow user impersonation which is a really great tool for support. But many times it makes sense to allow your support user to see different things than a user. We use a special role to achieve this behavior we can also have different roles for tiers of support.</p>

<p>By default even impersonation or user switching is turned off in the plugin by default. You can easily turn it on with a config flag:</p>

<p><code>
grails.plugin.springsecurity.useSwitchUserFilter = true
</code></p>

<p>Spring Security by default will add a new role of <a href="http://docs.spring.io/autorepo/docs/spring-security/3.2.1.RELEASE/apidocs/constant-values.html#org.springframework.security.web.authentication.switchuser.SwitchUserFilter.ROLE_PREVIOUS_ADMINISTRATOR">ROLE_PREVIOUS_ADMINISTRATOR</a> for the user while impersonating the other user. This will work in most cases but for us it was hard to reason about since we had an idea of admin which was separate from our support team who would mostly be using this tool.</p>

<p>So for our use we wanted our own roles. The ability to do this is exposed in the SwitchUserFilter calling <a href="http://docs.spring.io/autorepo/docs/spring-security/3.2.1.RELEASE/apidocs/org/springframework/security/web/authentication/switchuser/SwitchUserAuthorityChanger.html">SwitchUserAuthorityChanger</a>. With an implementation of the interface you can add any roles you would like.</p>

<p>Example authority changer:</p>

<p>```groovy
class RoleImpersonatedSwitchUserAuthorityChanger implements SwitchUserAuthorityChanger {</p>

<pre><code>@Override
public Collection&lt;GrantedAuthority&gt; modifyGrantedAuthorities(UserDetails targetUser, Authentication currentAuthentication, Collection&lt;GrantedAuthority&gt; authoritiesToBeGranted) {
    SwitchUserGrantedAuthority roleImpersonatedSwitchAuthority = new SwitchUserGrantedAuthority("ROLE_IMPERSONATED_USER", currentAuthentication);

    Collection&lt;? extends GrantedAuthority&gt; augmentedAuthoritiesToBeGranted = authoritiesToBeGranted + roleImpersonatedSwitchAuthority

    return augmentedAuthoritiesToBeGranted;
}
</code></pre>

<p>}
```</p>

<p>In Grails we set our authority changer during bootstrap.</p>

<p>```groovy BootStrap.groovy</p>

<p>class BootStrap {</p>

<pre><code>def switchUserProcessingFilter
def switchUserAuthorityChanger

def rabbitTemplate

def init = { servletContext -&gt;  
switchUserProcessingFilter.setSwitchUserAuthorityChanger(switchUserAuthorityChanger)

//....
</code></pre>

<p>  }
```</p>

<p>The switch user filter is already exposed as a bean so we can just get that injected and we also exposed the authority changer as a bean so we could just inject it in bootstrap.</p>

<p>There are many other options to think about when allowing impersonation of users, it may even make sense to remove some roles from an impersonated user. That is easily done by simply removing roles from the list retuned from the authority changer.</p>
]]></content>
  </entry>
  
</feed>
