<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Grails | Jeff Beck]]></title>
  <link href="http://beckje01.com/blog/categories/grails/atom.xml" rel="self"/>
  <link href="http://beckje01.com/"/>
  <updated>2015-02-14T15:42:52-06:00</updated>
  <id>http://beckje01.com/</id>
  <author>
    <name><![CDATA[Jeff Beck]]></name>
    <email><![CDATA[beckje01@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grails Integration Testing of Complex Transactions]]></title>
    <link href="http://beckje01.com/blog/2015/02/14/grails-integration-testing-of-complex-transactions/"/>
    <updated>2015-02-14T15:41:00-06:00</updated>
    <id>http://beckje01.com/blog/2015/02/14/grails-integration-testing-of-complex-transactions</id>
    <content type="html"><![CDATA[<p>Integration testing complex transactions in grails can be tricky due to the default behavior of wrapping integration tests in transactions and rolling them back when complete.</p>

<p>The simple solution is to simply turn off transactions for integration tests, that solution will work but tends to lead to data pollution in downstream tests. Burt Beckwith has a solution in his post <a href="http://burtbeckwith.com/blog/?p=82">An Alternative Approach for Grails Integration Tests</a>. Using this solution we can rebuild the database for each test.</p>

<p>In general most of the time you can use the default transactional testing behavior, therefore we want to only use this method some of the time. To achieve this effect we will modify Burt&rsquo;s original solution slightly.</p>

<ul>
<li>Rebuild the database <em>after</em> each test</li>
<li>Depend on the configured data source</li>
<li>Update to Spock</li>
</ul>


<h2>Updated Solution</h2>

<p>```groovy NonTransactionalIntegrationSpec.groovy
import org.codehaus.groovy.grails.orm.hibernate.cfg.DefaultGrailsDomainConfiguration
import org.hibernate.SessionFactory
import org.hibernate.cfg.Configuration
import org.hibernate.tool.hbm2ddl.SchemaExport</p>

<p>class NonTransactionalIntegrationSpec extends company.IntegrationSpec {</p>

<pre><code>@Shared
private static Configuration _configuration

@Shared
def grailsApplication

static transactional = false

def setupSpec() {
    if (!_configuration) {
        // 1-time creation of the configuration
        Properties properties = new Properties()
        properties.setProperty 'hibernate.connection.driver_class', grailsApplication.config.dataSource.driverClassName
        properties.setProperty 'hibernate.connection.username', grailsApplication.config.dataSource.username
        properties.setProperty 'hibernate.connection.password', grailsApplication.config.dataSource.password
        properties.setProperty 'hibernate.connection.url', grailsApplication.config.dataSource.url
        properties.setProperty 'hibernate.dialect', 'org.hibernate.dialect.H2Dialect'

        _configuration = new DefaultGrailsDomainConfiguration(grailsApplication: grailsApplication, properties: properties)
    }
}

def cleanupSpec() {
  //After spec nuke and pave the test db
  new SchemaExport(_configuration).create(false, true)

  //Clear the sessions
  SessionFactory sf = grailsApplication.getMainContext().getBean('sessionFactory')
  sf.getCurrentSession().clear()
}
</code></pre>

<p>}
```
You&rsquo;ll notice we extend a company.IntegrationSpec there isn&rsquo;t anything special in that just a base integration spec class that can hold our shared testing code such as bootstrapping methods and security methods. Since our data bootstrap logic is set up there we can share the same initial setup across both our normal integration test and our new non-transactional integration specs.</p>

<h2>When to Use</h2>

<p>The main time we started to need this new testing method was when doing custom propagation of hibernate transactions.</p>

<p>```groovy
  @Transactional(readOnly = true, propagation = Propagation.REQUIRES_NEW)
  def getSomething(){</p>

<pre><code>//Do some read only operation.
</code></pre>

<p>  }
```</p>

<p>Since this will require a new transaction we will not be able to see the inserts that have happened in the default transaction. We do many of our reads as read only and force a new transaction when we are more read heavy during an operation.</p>

<p>In general anytime you are working directly with transaction rollbacks or propagation it best to test those things directly without having Grails inject an extra transaction in there for you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcached Tomcat Sessions and Grails App Info Plugin]]></title>
    <link href="http://beckje01.com/blog/2015/01/14/memcached-tomcat-sessions-and-grails-app-info-plugin/"/>
    <updated>2015-01-14T20:46:00-06:00</updated>
    <id>http://beckje01.com/blog/2015/01/14/memcached-tomcat-sessions-and-grails-app-info-plugin</id>
    <content type="html"><![CDATA[<p>The <a href="http://grails.org/plugin/app-info">App Info Plugin</a> for Grails is a great tool. We use it in most of our Grails deployments. One of the great features offered is the ability to view all current sessions and their details. Another tool we are using is <a href="https://code.google.com/p/memcached-session-manager/">Memcached Session Manager</a> which allows shared sessions between our Tomcat servers, great for rolling deploys and high availability.</p>

<p>We found an issue while running both of these in production. Over time the number of sessions reported by App Info would grow extremely large. It turns out that having the App Info plugin track sessions for you when the sessions are shared via memcached can lead to the plugin holding onto references to sessions that have been destroyed on other severs.</p>

<p>So at this time we can&rsquo;t use the App Info plugin session tracking with the Memcached Session Manager, since it leads to a memory leak as all those sessions have references inside the plugin and can never be garbage collected.</p>

<p>We can simply turn off the session tracking with the following code:</p>

<p><code>groovy
grails.plugins.appinfo.useContextListener = false
</code></p>

<p>But note this config change effect will effect how a war is made so you can&rsquo;t simply override this in production you will need a new war built.</p>

<p>Below is our memory graph before and after the change:</p>

<p><img src="/images/memchange.png" alt="Graph showing memory usage before and after the config change." /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails New Relic Detailed Tracing]]></title>
    <link href="http://beckje01.com/blog/2014/07/03/grails-new-relic-detailed-tracing/"/>
    <updated>2014-07-03T09:36:21-05:00</updated>
    <id>http://beckje01.com/blog/2014/07/03/grails-new-relic-detailed-tracing</id>
    <content type="html"><![CDATA[<p>New Relic with Grails by default will trace most web transactions through the controller but will not trace down into services. While most true work of a request belongs in services or libraries the default tracing leaves something to be desired.</p>

<p>This is easily fixed by adding New Relic annotations to services and libraries.</p>

<h3>BuildConfig.groovy Changes</h3>

<p>``` groovy
dependencies {</p>

<pre><code>compile 'com.newrelic.agent.java:newrelic-api:3.4.2'
</code></pre>

<p>}
```</p>

<h3>Service Changes</h3>

<p>``` groovy
import com.newrelic.api.agent.Trace</p>

<p>class SubscriptionService {</p>

<pre><code>@Trace
def save(Subscription subscription) {
//Work Here
</code></pre>

<p>  }
```</p>

<p>At this point your code is ready to give more detailed transactions, but the agent on the server must also be configured to accept custom tracing. The config option for this is not available from the web so you must update the <code>newrelic.yml</code> file. Set <code>enable_custom_tracing</code> to <code>true</code>.</p>

<p><code>yaml
  #enable_custom_tracing is used to allow @Trace on methods
  enable_custom_tracing: true
</code></p>

<p>Now you will get any custom tracing added to your application as well as custom tracing from libraries.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails 2.3.1 Warnings after clean.]]></title>
    <link href="http://beckje01.com/blog/2013/10/23/grails-2-3-1-warnings-after-clean/"/>
    <updated>2013-10-23T04:02:02-05:00</updated>
    <id>http://beckje01.com/blog/2013/10/23/grails-2-3-1-warnings-after-clean</id>
    <content type="html"><![CDATA[<p>If you are running grails 2.3.1 and see the following sequence pop up before you get some odd test failures.</p>

<p>``` sh</p>

<pre><code>$ grails clean
| Application cleaned.

$ grails test-app
| Environment set to test.....
| Warning No config found for the application.
| Warning DataSource.groovy not found, assuming dataSource bean is configured by Spring
</code></pre>

<p>```
Start using package in between and the problem will go away.</p>

<p>``` sh</p>

<pre><code>$ grails clean
| Application cleaned.
$ grails package
| Compiling 10 source files
| Compiling 12 source files.....

$ grails test-app
| Environment set to test.....
| Server running. Browse to http://localhost:8080/api
| Running 6 cucumber tests...
| Completed 6 cucumber tests, 0 failed in 0m 3s
| Server stopped
| Tests PASSED
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails 2.3 RC1 and JMS Plugin]]></title>
    <link href="http://beckje01.com/blog/2013/08/19/grails-2-3-rc1-and-jms-plugin/"/>
    <updated>2013-08-19T18:10:12-05:00</updated>
    <id>http://beckje01.com/blog/2013/08/19/grails-2-3-rc1-and-jms-plugin</id>
    <content type="html"><![CDATA[<p>Using the JMS 1.2 plugin with Grails 2.3.0.RC1 was producing a number of odd results. Mostly with missing JMS files it turns out that the new spring version didnâ€™t have the needed spring jms included. Just add the following to BuildConfig.groovy</p>

<p>``` groovy</p>

<pre><code>dependencies {
  compile 'org.springframework:spring-jms:3.2.4.RELEASE'
  ...
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
