<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Jeff Beck]]></title>
  <link href="http://beckje01.com/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://beckje01.com/"/>
  <updated>2014-09-17T09:21:42-05:00</updated>
  <id>http://beckje01.com/</id>
  <author>
    <name><![CDATA[Jeff Beck]]></name>
    <email><![CDATA[beckje01@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ratpack Promise]]></title>
    <link href="http://beckje01.com/blog/2014/09/10/ratpack-promise/"/>
    <updated>2014-09-10T15:33:46-05:00</updated>
    <id>http://beckje01.com/blog/2014/09/10/ratpack-promise</id>
    <content type="html"><![CDATA[<p>Ratpack has a core class that is the center of the great asynchronous support, <a href="http://www.ratpack.io/manual/current/api/index.html?ratpack/exec/Promise.html">Promise</a>.</p>

<p>Ratpack Promises are very easy to work with, there are just a few key points:</p>

<ul>
<li>Only attach to a promise one time</li>
<li>If dealing with the error case it must be done before the success case</li>
<li>They are Lazy</li>
<li>In Groovy we depend on <a href="http://mrhaki.blogspot.com/2013/11/groovy-goodness-implicit-closure.html">Implicit Closure Coercion</a> to change our closures to an Action.</li>
</ul>


<h2>Happy Path</h2>

<p>``` groovy Consuming Value from Promise
Promise promise = somethingThatReturnsPromise()</p>

<p>promise.then {
  println it
}
```</p>

<p>What we are doing here is giving a closure to the promise that once the value is ready the closure will be called with the value passed in as a parameter. We can also be very explicit in what we are getting back from the promise.</p>

<p>``` groovy Explicit Value from Promise
def p = httpClient.get {
  it.url.set(new URI(&ldquo;<a href="http://example.com">http://example.com</a>&rdquo;))
}</p>

<p>p.then { ReceivedResponse receivedResponse &ndash;>
  println receivedResponse.statusCode
}
<code>``
If some error occurs while trying to get the value for the</code>then` block the exception will be thrown. Which can be picked up by some error handler down the chain.</p>

<h2>Error Callback</h2>

<p>So for this works great when dealing with the happy path and wanting exceptions. But we also may want to deal with failures to fulfill the promise. So to do this we start with <code>onError</code> instead of <code>then</code>.</p>

<p>``` groovy Ratpack Promise with Failure Path
httpClient.get {</p>

<pre><code>it.url.set(new URI("http://example.com"))
</code></pre>

<p>} onError {</p>

<pre><code>println "Something when wrong: ${it.message}"
</code></pre>

<p>} then {</p>

<pre><code>render "Got a ${it.statusCode} status with body of:\n\n${it.body.text}"
</code></pre>

<p>}
<code>``
</code>onError` will pass in a throwable to the closure that you can log or do whatever work you would like in the case of a failure.</p>

<h2>Lazy Promises</h2>

<p>Ratpack promises won&rsquo;t actually try to generate the value until the <code>then</code> block is called at the end of the current execution. This is done to allow for deterministic asynchronous operations.</p>

<p><code>groovy Deterministic Promise
def doWork() {
  httpClient.get { … }.then { … }
  sleep 5000
  throw new RuntimeException("bang!")
}
</code></p>

<p>What will happen in Ratpack is we will always get the exception &ldquo;bang!&rdquo;, because the get request will not even get started until the <code>doWork</code> block of execution is finished. Once finished having a <code>then{}</code> will trigger a background thread to start generating the value.</p>

<h2>What not to do</h2>

<p>You shouldn&rsquo;t try to attach more than once to a Promise, as what ends up happening is two different promise instances will execute in the background and what we want is only to deal with that value once. So don&rsquo;t do the following:</p>

<p>``` groovy Don&rsquo;t do this</p>

<p>def p = httpClient.get {
  it.url.set(new URI(&ldquo;<a href="http://example.com">http://example.com</a>&rdquo;))
}</p>

<p>p.onError {
  println it
}</p>

<p>p.then {
  println it.statusCode
}</p>

<p>```
Starting in Ratpack 0.9.9 the above code should actually throw an error.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Failing @Grab Fixes]]></title>
    <link href="http://beckje01.com/blog/2014/07/25/failing-at-grab-fixes/"/>
    <updated>2014-07-25T06:54:30-05:00</updated>
    <id>http://beckje01.com/blog/2014/07/25/failing-at-grab-fixes</id>
    <content type="html"><![CDATA[<p>If you are working on a Groovy script with @Grab, you will sometimes get download failures for dependencies. Such as the following:</p>

<p><code>
General error during conversion: Error grabbing Grapes -- [download failed: com.google.guava#guava;16.0!guava.jar(bundle), download failed: org.javassist#javassist;3.18.1-GA!javassist.jar(bundle)]
</code></p>

<p>This issues may have nothing to do with the actual dependency but an issue in your local m2 cache. The quick answer is to just delete <code>~/.groovy/grapes</code> and <code>~/.m2/repository</code>. But doing this will force you to re-download dependencies.</p>

<p>To only delete the cache for items giving you an issue you just need to delete the correct directories in both m2 and grapes cache. So for our Guava example you would do the following:</p>

<p>```
rm -r ~/.groovy/grapes/com.google.guava
rm -r ~/.m2/repository/com/google/guava</p>

<p>```</p>

<p>After that you should be able to run the groovy script normally.</p>
]]></content>
  </entry>
  
</feed>
