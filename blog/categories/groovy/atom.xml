<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Jeff Beck]]></title>
  <link href="http://beckje01.com/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://beckje01.com/"/>
  <updated>2015-07-12T21:30:01-05:00</updated>
  <id>http://beckje01.com/</id>
  <author>
    <name><![CDATA[Jeff Beck]]></name>
    <email><![CDATA[beckje01@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grails 3 and JaCoCo]]></title>
    <link href="http://beckje01.com/blog/2015/07/12/grails-3-and-jacoco/"/>
    <updated>2015-07-12T21:29:00-05:00</updated>
    <id>http://beckje01.com/blog/2015/07/12/grails-3-and-jacoco</id>
    <content type="html"><![CDATA[<p>Now that we have Gradle as our build system we have a whole range of plugins we can use directly in Gradle. For code coverage I am using the JaCoCo plugin. To use it with Grails we just apply the plugin to the build. By default you will get a HTML report, in the <code>build/report/jacoco</code> directory.</p>

<p><code>groovy
apply plugin: "jacoco"
</code></p>

<p>But Grails 3 has it&rsquo;s test phases split up, out of the box you will have <code>test</code> and <code>integrationTest</code>. Starting with the JaCoCo gradle plugin, you will get coverage for just your <code>test</code> phase.</p>

<p>We can easily fix this by letting JaCoCo know about the phases we want reported on so we just adjust the config for the jacocoTestReport task.</p>

<p>```groovy
jacocoTestReport {</p>

<pre><code>executionData integrationTest, test
//...
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails 3 and Spring Java Config]]></title>
    <link href="http://beckje01.com/blog/2015/04/24/grails-3-and-spring-java-config/"/>
    <updated>2015-04-24T21:52:53-05:00</updated>
    <id>http://beckje01.com/blog/2015/04/24/grails-3-and-spring-java-config</id>
    <content type="html"><![CDATA[<p>The Spring Java config is a great way to work with Spring configuration. It feels similar to Google Guice, which I personally enjoy. Mr. Haki did a great write up on using it with <a href="http://mrhaki.blogspot.com/2014/08/grails-goodness-use-spring-java.html">Grails 2.4</a>.</p>

<p>While working with Grails 3 there are a few areas that don&rsquo;t have plugins yet but do have Spring modules we can leverage. So I started out with the same path given for Grails 2.X.</p>

<p>```yaml application.yml
grails:</p>

<pre><code>profile: web
codegen:
    defaultPackage: example
spring:
    bean:
        packages:
            - example.config
</code></pre>

<p>```</p>

<p>I found that while the beans were all wired correctly and <code>@Autowired</code> all worked correctly, but any mappings with <code>@RequestMapping</code> where always returning a 404. Everything looked wired correctly but Grails wasn&rsquo;t letting any requests through.</p>

<p>So I switched over to using <code>@ComponentScan</code> then the requests were properly mapped and everything started working.</p>

<p>Using ComponentScan with Grails 3 is very easy:</p>

<p><code>groovy Application.groovy
@ComponentScan("example.config")
class Application extends GrailsAutoConfiguration {
  //...
}
</code></p>

<p>This will scan the package of <code>example.config</code> for any Spring components so your Spring Java configs can all live in this package and easily get picked up.</p>

<p>This post is the blog form of this <a href="http://stackoverflow.com/questions/29736850/grails-3-and-spring-requestmapping">SO Question</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringSecurity Impersonate Users Custom Roles]]></title>
    <link href="http://beckje01.com/blog/2015/04/18/springsecurity-impersonate-users-custom-roles/"/>
    <updated>2015-04-18T20:54:00-05:00</updated>
    <id>http://beckje01.com/blog/2015/04/18/springsecurity-impersonate-users-custom-roles</id>
    <content type="html"><![CDATA[<p>The Grails SpringSecurity plugin has the ability to allow user impersonation which is a really great tool for support. But many times it makes sense to allow your support user to see different things than a user. We use a special role to achieve this behavior we can also have different roles for tiers of support.</p>

<p>By default even impersonation or user switching is turned off in the plugin by default. You can easily turn it on with a config flag:</p>

<p><code>
grails.plugin.springsecurity.useSwitchUserFilter = true
</code></p>

<p>Spring Security by default will add a new role of <a href="http://docs.spring.io/autorepo/docs/spring-security/3.2.1.RELEASE/apidocs/constant-values.html#org.springframework.security.web.authentication.switchuser.SwitchUserFilter.ROLE_PREVIOUS_ADMINISTRATOR">ROLE_PREVIOUS_ADMINISTRATOR</a> for the user while impersonating the other user. This will work in most cases but for us it was hard to reason about since we had an idea of admin which was separate from our support team who would mostly be using this tool.</p>

<p>So for our use we wanted our own roles. The ability to do this is exposed in the SwitchUserFilter calling <a href="http://docs.spring.io/autorepo/docs/spring-security/3.2.1.RELEASE/apidocs/org/springframework/security/web/authentication/switchuser/SwitchUserAuthorityChanger.html">SwitchUserAuthorityChanger</a>. With an implementation of the interface you can add any roles you would like.</p>

<p>Example authority changer:</p>

<p>```groovy
class RoleImpersonatedSwitchUserAuthorityChanger implements SwitchUserAuthorityChanger {</p>

<pre><code>@Override
public Collection&lt;GrantedAuthority&gt; modifyGrantedAuthorities(UserDetails targetUser, Authentication currentAuthentication, Collection&lt;GrantedAuthority&gt; authoritiesToBeGranted) {
    SwitchUserGrantedAuthority roleImpersonatedSwitchAuthority = new SwitchUserGrantedAuthority("ROLE_IMPERSONATED_USER", currentAuthentication);

    Collection&lt;? extends GrantedAuthority&gt; augmentedAuthoritiesToBeGranted = authoritiesToBeGranted + roleImpersonatedSwitchAuthority

    return augmentedAuthoritiesToBeGranted;
}
</code></pre>

<p>}
```</p>

<p>In Grails we set our authority changer during bootstrap.</p>

<p>```groovy BootStrap.groovy</p>

<p>class BootStrap {</p>

<pre><code>def switchUserProcessingFilter
def switchUserAuthorityChanger

def rabbitTemplate

def init = { servletContext -&gt;  
switchUserProcessingFilter.setSwitchUserAuthorityChanger(switchUserAuthorityChanger)

//....
</code></pre>

<p>  }
```</p>

<p>The switch user filter is already exposed as a bean so we can just get that injected and we also exposed the authority changer as a bean so we could just inject it in bootstrap.</p>

<p>There are many other options to think about when allowing impersonation of users, it may even make sense to remove some roles from an impersonated user. That is easily done by simply removing roles from the list retuned from the authority changer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grails Integration Testing of Complex Transactions]]></title>
    <link href="http://beckje01.com/blog/2015/02/14/grails-integration-testing-of-complex-transactions/"/>
    <updated>2015-02-14T15:41:00-06:00</updated>
    <id>http://beckje01.com/blog/2015/02/14/grails-integration-testing-of-complex-transactions</id>
    <content type="html"><![CDATA[<p>Integration testing complex transactions in grails can be tricky due to the default behavior of wrapping integration tests in transactions and rolling them back when complete.</p>

<p>The simple solution is to simply turn off transactions for integration tests, that solution will work but tends to lead to data pollution in downstream tests. Burt Beckwith has a solution in his post <a href="http://burtbeckwith.com/blog/?p=82">An Alternative Approach for Grails Integration Tests</a>. Using this solution we can rebuild the database for each test.</p>

<p>In general most of the time you can use the default transactional testing behavior, therefore we want to only use this method some of the time. To achieve this effect we will modify Burt&rsquo;s original solution slightly.</p>

<ul>
<li>Rebuild the database <em>after</em> each test</li>
<li>Depend on the configured data source</li>
<li>Update to Spock</li>
</ul>


<h2>Updated Solution</h2>

<p>```groovy NonTransactionalIntegrationSpec.groovy
import org.codehaus.groovy.grails.orm.hibernate.cfg.DefaultGrailsDomainConfiguration
import org.hibernate.SessionFactory
import org.hibernate.cfg.Configuration
import org.hibernate.tool.hbm2ddl.SchemaExport</p>

<p>class NonTransactionalIntegrationSpec extends company.IntegrationSpec {</p>

<pre><code>@Shared
private static Configuration _configuration

@Shared
def grailsApplication

static transactional = false

def setupSpec() {
    if (!_configuration) {
        // 1-time creation of the configuration
        Properties properties = new Properties()
        properties.setProperty 'hibernate.connection.driver_class', grailsApplication.config.dataSource.driverClassName
        properties.setProperty 'hibernate.connection.username', grailsApplication.config.dataSource.username
        properties.setProperty 'hibernate.connection.password', grailsApplication.config.dataSource.password
        properties.setProperty 'hibernate.connection.url', grailsApplication.config.dataSource.url
        properties.setProperty 'hibernate.dialect', 'org.hibernate.dialect.H2Dialect'

        _configuration = new DefaultGrailsDomainConfiguration(grailsApplication: grailsApplication, properties: properties)
    }
}

def cleanupSpec() {
  //After spec nuke and pave the test db
  new SchemaExport(_configuration).create(false, true)

  //Clear the sessions
  SessionFactory sf = grailsApplication.getMainContext().getBean('sessionFactory')
  sf.getCurrentSession().clear()
}
</code></pre>

<p>}
```
You&rsquo;ll notice we extend a company.IntegrationSpec there isn&rsquo;t anything special in that just a base integration spec class that can hold our shared testing code such as bootstrapping methods and security methods. Since our data bootstrap logic is set up there we can share the same initial setup across both our normal integration test and our new non-transactional integration specs.</p>

<h2>When to Use</h2>

<p>The main time we started to need this new testing method was when doing custom propagation of hibernate transactions.</p>

<p>```groovy
  @Transactional(readOnly = true, propagation = Propagation.REQUIRES_NEW)
  def getSomething(){</p>

<pre><code>//Do some read only operation.
</code></pre>

<p>  }
```</p>

<p>Since this will require a new transaction we will not be able to see the inserts that have happened in the default transaction. We do many of our reads as read only and force a new transaction when we are more read heavy during an operation.</p>

<p>In general anytime you are working directly with transaction rollbacks or propagation it best to test those things directly without having Grails inject an extra transaction in there for you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcached Tomcat Sessions and Grails App Info Plugin]]></title>
    <link href="http://beckje01.com/blog/2015/01/14/memcached-tomcat-sessions-and-grails-app-info-plugin/"/>
    <updated>2015-01-14T20:46:00-06:00</updated>
    <id>http://beckje01.com/blog/2015/01/14/memcached-tomcat-sessions-and-grails-app-info-plugin</id>
    <content type="html"><![CDATA[<p>The <a href="http://grails.org/plugin/app-info">App Info Plugin</a> for Grails is a great tool. We use it in most of our Grails deployments. One of the great features offered is the ability to view all current sessions and their details. Another tool we are using is <a href="https://code.google.com/p/memcached-session-manager/">Memcached Session Manager</a> which allows shared sessions between our Tomcat servers, great for rolling deploys and high availability.</p>

<p>We found an issue while running both of these in production. Over time the number of sessions reported by App Info would grow extremely large. It turns out that having the App Info plugin track sessions for you when the sessions are shared via memcached can lead to the plugin holding onto references to sessions that have been destroyed on other severs.</p>

<p>So at this time we can&rsquo;t use the App Info plugin session tracking with the Memcached Session Manager, since it leads to a memory leak as all those sessions have references inside the plugin and can never be garbage collected.</p>

<p>We can simply turn off the session tracking with the following code:</p>

<p><code>groovy
grails.plugins.appinfo.useContextListener = false
</code></p>

<p>But note this config change effect will effect how a war is made so you can&rsquo;t simply override this in production you will need a new war built.</p>

<p>Below is our memory graph before and after the change:</p>

<p><img src="/images/memchange.png" alt="Graph showing memory usage before and after the config change." /></p>
]]></content>
  </entry>
  
</feed>
