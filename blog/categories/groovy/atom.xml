<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Jeff Beck]]></title>
  <link href="http://beckje01.com/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://beckje01.com/"/>
  <updated>2015-02-14T15:42:52-06:00</updated>
  <id>http://beckje01.com/</id>
  <author>
    <name><![CDATA[Jeff Beck]]></name>
    <email><![CDATA[beckje01@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grails Integration Testing of Complex Transactions]]></title>
    <link href="http://beckje01.com/blog/2015/02/14/grails-integration-testing-of-complex-transactions/"/>
    <updated>2015-02-14T15:41:00-06:00</updated>
    <id>http://beckje01.com/blog/2015/02/14/grails-integration-testing-of-complex-transactions</id>
    <content type="html"><![CDATA[<p>Integration testing complex transactions in grails can be tricky due to the default behavior of wrapping integration tests in transactions and rolling them back when complete.</p>

<p>The simple solution is to simply turn off transactions for integration tests, that solution will work but tends to lead to data pollution in downstream tests. Burt Beckwith has a solution in his post <a href="http://burtbeckwith.com/blog/?p=82">An Alternative Approach for Grails Integration Tests</a>. Using this solution we can rebuild the database for each test.</p>

<p>In general most of the time you can use the default transactional testing behavior, therefore we want to only use this method some of the time. To achieve this effect we will modify Burt&rsquo;s original solution slightly.</p>

<ul>
<li>Rebuild the database <em>after</em> each test</li>
<li>Depend on the configured data source</li>
<li>Update to Spock</li>
</ul>


<h2>Updated Solution</h2>

<p>```groovy NonTransactionalIntegrationSpec.groovy
import org.codehaus.groovy.grails.orm.hibernate.cfg.DefaultGrailsDomainConfiguration
import org.hibernate.SessionFactory
import org.hibernate.cfg.Configuration
import org.hibernate.tool.hbm2ddl.SchemaExport</p>

<p>class NonTransactionalIntegrationSpec extends company.IntegrationSpec {</p>

<pre><code>@Shared
private static Configuration _configuration

@Shared
def grailsApplication

static transactional = false

def setupSpec() {
    if (!_configuration) {
        // 1-time creation of the configuration
        Properties properties = new Properties()
        properties.setProperty 'hibernate.connection.driver_class', grailsApplication.config.dataSource.driverClassName
        properties.setProperty 'hibernate.connection.username', grailsApplication.config.dataSource.username
        properties.setProperty 'hibernate.connection.password', grailsApplication.config.dataSource.password
        properties.setProperty 'hibernate.connection.url', grailsApplication.config.dataSource.url
        properties.setProperty 'hibernate.dialect', 'org.hibernate.dialect.H2Dialect'

        _configuration = new DefaultGrailsDomainConfiguration(grailsApplication: grailsApplication, properties: properties)
    }
}

def cleanupSpec() {
  //After spec nuke and pave the test db
  new SchemaExport(_configuration).create(false, true)

  //Clear the sessions
  SessionFactory sf = grailsApplication.getMainContext().getBean('sessionFactory')
  sf.getCurrentSession().clear()
}
</code></pre>

<p>}
```
You&rsquo;ll notice we extend a company.IntegrationSpec there isn&rsquo;t anything special in that just a base integration spec class that can hold our shared testing code such as bootstrapping methods and security methods. Since our data bootstrap logic is set up there we can share the same initial setup across both our normal integration test and our new non-transactional integration specs.</p>

<h2>When to Use</h2>

<p>The main time we started to need this new testing method was when doing custom propagation of hibernate transactions.</p>

<p>```groovy
  @Transactional(readOnly = true, propagation = Propagation.REQUIRES_NEW)
  def getSomething(){</p>

<pre><code>//Do some read only operation.
</code></pre>

<p>  }
```</p>

<p>Since this will require a new transaction we will not be able to see the inserts that have happened in the default transaction. We do many of our reads as read only and force a new transaction when we are more read heavy during an operation.</p>

<p>In general anytime you are working directly with transaction rollbacks or propagation it best to test those things directly without having Grails inject an extra transaction in there for you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcached Tomcat Sessions and Grails App Info Plugin]]></title>
    <link href="http://beckje01.com/blog/2015/01/14/memcached-tomcat-sessions-and-grails-app-info-plugin/"/>
    <updated>2015-01-14T20:46:00-06:00</updated>
    <id>http://beckje01.com/blog/2015/01/14/memcached-tomcat-sessions-and-grails-app-info-plugin</id>
    <content type="html"><![CDATA[<p>The <a href="http://grails.org/plugin/app-info">App Info Plugin</a> for Grails is a great tool. We use it in most of our Grails deployments. One of the great features offered is the ability to view all current sessions and their details. Another tool we are using is <a href="https://code.google.com/p/memcached-session-manager/">Memcached Session Manager</a> which allows shared sessions between our Tomcat servers, great for rolling deploys and high availability.</p>

<p>We found an issue while running both of these in production. Over time the number of sessions reported by App Info would grow extremely large. It turns out that having the App Info plugin track sessions for you when the sessions are shared via memcached can lead to the plugin holding onto references to sessions that have been destroyed on other severs.</p>

<p>So at this time we can&rsquo;t use the App Info plugin session tracking with the Memcached Session Manager, since it leads to a memory leak as all those sessions have references inside the plugin and can never be garbage collected.</p>

<p>We can simply turn off the session tracking with the following code:</p>

<p><code>groovy
grails.plugins.appinfo.useContextListener = false
</code></p>

<p>But note this config change effect will effect how a war is made so you can&rsquo;t simply override this in production you will need a new war built.</p>

<p>Below is our memory graph before and after the change:</p>

<p><img src="/images/memchange.png" alt="Graph showing memory usage before and after the config change." /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ratpack Promise]]></title>
    <link href="http://beckje01.com/blog/2014/09/10/ratpack-promise/"/>
    <updated>2014-09-10T15:33:46-05:00</updated>
    <id>http://beckje01.com/blog/2014/09/10/ratpack-promise</id>
    <content type="html"><![CDATA[<p>Ratpack has a core class that is the center of the great asynchronous support, <a href="http://www.ratpack.io/manual/current/api/index.html?ratpack/exec/Promise.html">Promise</a>.</p>

<p>Ratpack Promises are very easy to work with, there are just a few key points:</p>

<ul>
<li>Only attach to a promise one time</li>
<li>If dealing with the error case it must be done before the success case</li>
<li>They are Lazy</li>
<li>In Groovy we depend on <a href="http://mrhaki.blogspot.com/2013/11/groovy-goodness-implicit-closure.html">Implicit Closure Coercion</a> to change our closures to an Action.</li>
</ul>


<h2>Happy Path</h2>

<p>``` groovy Consuming Value from Promise
Promise promise = somethingThatReturnsPromise()</p>

<p>promise.then {
  println it
}
```</p>

<p>What we are doing here is giving a closure to the promise that once the value is ready the closure will be called with the value passed in as a parameter. We can also be very explicit in what we are getting back from the promise.</p>

<p>``` groovy Explicit Value from Promise
def p = httpClient.get {
  it.url.set(new URI(&ldquo;<a href="http://example.com">http://example.com</a>&rdquo;))
}</p>

<p>p.then { ReceivedResponse receivedResponse &ndash;>
  println receivedResponse.statusCode
}
<code>``
If some error occurs while trying to get the value for the</code>then` block the exception will be thrown. Which can be picked up by some error handler down the chain.</p>

<h2>Error Callback</h2>

<p>So for this works great when dealing with the happy path and wanting exceptions. But we also may want to deal with failures to fulfill the promise. So to do this we start with <code>onError</code> instead of <code>then</code>.</p>

<p>``` groovy Ratpack Promise with Failure Path
httpClient.get {</p>

<pre><code>it.url.set(new URI("http://example.com"))
</code></pre>

<p>} onError {</p>

<pre><code>println "Something when wrong: ${it.message}"
</code></pre>

<p>} then {</p>

<pre><code>render "Got a ${it.statusCode} status with body of:\n\n${it.body.text}"
</code></pre>

<p>}
<code>``
</code>onError` will pass in a throwable to the closure that you can log or do whatever work you would like in the case of a failure.</p>

<h2>Lazy Promises</h2>

<p>Ratpack promises won&rsquo;t actually try to generate the value until the <code>then</code> block is called at the end of the current execution. This is done to allow for deterministic asynchronous operations.</p>

<p><code>groovy Deterministic Promise
def doWork() {
  httpClient.get { … }.then { … }
  sleep 5000
  throw new RuntimeException("bang!")
}
</code></p>

<p>What will happen in Ratpack is we will always get the exception &ldquo;bang!&rdquo;, because the get request will not even get started until the <code>doWork</code> block of execution is finished. Once finished having a <code>then{}</code> will trigger a background thread to start generating the value.</p>

<h2>What not to do</h2>

<p>You shouldn&rsquo;t try to attach more than once to a Promise, as what ends up happening is two different promise instances will execute in the background and what we want is only to deal with that value once. So don&rsquo;t do the following:</p>

<p>``` groovy Don&rsquo;t do this</p>

<p>def p = httpClient.get {
  it.url.set(new URI(&ldquo;<a href="http://example.com">http://example.com</a>&rdquo;))
}</p>

<p>p.onError {
  println it
}</p>

<p>p.then {
  println it.statusCode
}</p>

<p>```
Starting in Ratpack 0.9.9 the above code should actually throw an error.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Failing @Grab Fixes]]></title>
    <link href="http://beckje01.com/blog/2014/07/25/failing-at-grab-fixes/"/>
    <updated>2014-07-25T06:54:30-05:00</updated>
    <id>http://beckje01.com/blog/2014/07/25/failing-at-grab-fixes</id>
    <content type="html"><![CDATA[<p>If you are working on a Groovy script with @Grab, you will sometimes get download failures for dependencies. Such as the following:</p>

<p><code>
General error during conversion: Error grabbing Grapes -- [download failed: com.google.guava#guava;16.0!guava.jar(bundle), download failed: org.javassist#javassist;3.18.1-GA!javassist.jar(bundle)]
</code></p>

<p>This issues may have nothing to do with the actual dependency but an issue in your local m2 cache. The quick answer is to just delete <code>~/.groovy/grapes</code> and <code>~/.m2/repository</code>. But doing this will force you to re-download dependencies.</p>

<p>To only delete the cache for items giving you an issue you just need to delete the correct directories in both m2 and grapes cache. So for our Guava example you would do the following:</p>

<p>```
rm -r ~/.groovy/grapes/com.google.guava
rm -r ~/.m2/repository/com/google/guava</p>

<p>```</p>

<p>After that you should be able to run the groovy script normally.</p>
]]></content>
  </entry>
  
</feed>
